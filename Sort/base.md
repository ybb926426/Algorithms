# 排序算法

## 冒泡排序(Bubble Sort)

重复地遍历要排序地数列，每次比较相邻地两个元素，如果他们的顺序错误就交换他们，直到没有需要交换地元素为止

时间复杂度: 平均情况和最坏情况都是O(n^2),最好情况是O(n)

空间复杂度: O(1)

## 选择排序(Selection Sort)

将数列分为已排序和未排序两部分，每次从未排序部分中选择最小(或最大)的元素，放到已排序部分的末尾，直到所有元素都已排序

时间复杂度:平均情况和最坏情况都是O(n^2),最好情况也是O(n^2)。

空间复杂度:O(1),是一种原地排序算法。

## 插入排序(Insertion Sort)

将数列分为已排序和未排序两部分，每次从未排序部分中取出第一个元素，插入到已排序部分的适当位置，直到所有元素都已排序

时间复杂度:平均情况和最坏情况都是O(n^2),最好情况是O(n)。

空间复杂度:O(1),是一种原地排序算法。

## 希尔排序(Shell Sort)

先将数列分为若干子序列，每个子序列都按照插入排序进行排序，然后将两个子序列合并成一个有序序列，直到整个序列都已排序

时间复杂度:平均情况、最坏情况和最好情况都是O(nlogn)。

空间复杂度:O(n),需要额外的空间来存储临时数组。

## 归并排序(Merge Sort)

将数列递归地分为两半,直到每个子序列只包含一个元素,然后将两个子序列合并成一个有序序列,直到整个数列都已排序

时间复杂度:平均情况、最坏情况和最好情况都是O(nlogn)。

空间复杂度:O(n),需要额外的空间来存储临时数组。

## 快速排序(Quick Sort)

从数列中挑出一个元素作为基准,将数列分为两个子序列,一个子序列的元素都小于等于基准,另一个子序列的元素都大于等于基准,然后递归地对两个子序列进行快速排序,直到整个数列都已排序。

时间复杂度:平均情况是O(nlogn),最坏情况是O(n^2),最好情况是O(nlogn)

## 堆排序(Heap Sort)

将数列构建成一个大根堆或小根堆,每次将堆顶元素与堆的最后一个元素交换,然后将堆的大小减一,并重新调整堆,直到整个数列都已排序

时间复杂度:平均情况、最坏情况和最好情况都是O(nlogn)。

空间复杂度:O(1),是一种原地排序算法。

## 计数排序(Counting Sort)

将数列中每个元素的出现次数记录在一个额外的数组中,然后根据出现次数来重构原数列

时间复杂度:O(n+k),其中k是数列中元素的取值范围。

空间复杂度:O(n+k),需要额外的空间来存储计数数组。

## 桶排序(Bucket Sort)

将数列分到若干个桶中,每个桶内的元素再使用其他排序算法(如插入排序)进行排序,最后将所有桶中的元素合并成一个有序数列

时间复杂度:平均情况是O(n+k),最坏情况是O(n^2),其中k是桶的数量

空间复杂度:O(n+k),需要额外的空间来存储桶

## 基数排序(Radix Sort)

将数列按照每个元素的每一位数字来进行排序,从最低位开始,每次按照一个位数来排序,直到最高位,最后得到一个有序数列

时间复杂度:O(d*(n+k)),其中d是元素的最大位数,k是每一位的取值范围

空间复杂度:O(n+k),需要额外的空间来存储临时数组
