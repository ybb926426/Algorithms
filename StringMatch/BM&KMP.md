# BM&KMP

## BM算法 （Boyer-Moore）

BM算法是一种非常高效的字符串匹配算法，实现原理复杂；

核心思想：我们把模式串和主串的匹配过程，看作模式串在主串中不停的往后滑，当遇到不匹配的字符时，BF和RK算法的做法是，模式串往后滑动以为，然后从模式串的第一个字符开始重新匹配；BM算法是模式串和主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位；

### 原理分析

- 坏字符规则（bad character rule）
  - 从模式串的末尾往前倒着匹配，当发现某个字符没法匹配的时候，我们就把这个没有匹配的字符叫做坏字符（主串中的字符）
  - 当发生不匹配的时候，我们把坏字符对应的字符下标记做si；如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记做xi；如果不存在，我们把xi记做-1.那模式串往后移动的位数就是 si - xi
- 好后缀规则（good suffix shift）
  - 我们把已经匹配好的字符串叫做好后缀，记做{u}，我们拿它在模式串中查找，如果找到了另一个跟{u}相匹配的{u*}，我们就将模式串滑动到子串{u*}与主串中{u}对齐的位置。
  - 如果在模式串中找不到另一个等于{u}的子串，我们就直接将模式串，滑动到主串中{u}的后面，因为之前的任何一次往后滑动，都没有匹配主串中{u}的情况

BM 算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。BM 算法构建的规则有两类，坏字符规则和好后缀规则。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，我们可以只用好后缀规则来实现 BM 算法。

## KMP算法 （D.E.Knuth，J.H.Morris 和 V.R.Pratt的名字来命名的; Knuth Morris Pratt）

KMP算法是一种用于在文本串中查找子串的高效字符串匹配算法

核心思想是：利用已经匹配过的信息来避免不必要的重复比较，从而提高匹配效率。与朴素的字符串匹配算法相比：KMP算法在最坏情况下的时间复杂度从O(mn)降低到了O(m+n)，其中m是模式串的长度,n是文本串的长度

### 原理和实现步骤

- 构建失配函数(也称为前缀函数或部分匹配表)
  - 失配函数用于记录模式串中每个位置之前的子串的最长相等前后缀的长度。
  - 定义失配函数next[i]表示模式串中第i个字符之前的子串的最长相等前后缀的长度。
  - 通过预处理模式串,计算出每个位置的失配函数值,存储在数组next中
- 利用失配函数进行匹配
  - 使用两个指针i和j,分别指向文本串和模式串的当前位置。
  - 从左到右逐个比较文本串和模式串的字符:
    - 如果文本串的第i个字符与模式串的第j个字符匹配,则i和j分别向右移动一位,继续比较下一个字符。
    - 如果文本串的第i个字符与模式串的第j个字符不匹配,则利用失配函数next[j-1]来确定模式串下一次匹配的位置:
    - 将j移动到next[j-1]的位置,即j = next[j-1]。
      - 如果j等于0,表示模式串已经回到了开头,此时将i向右移动一位,j保持不变。
    重复上述过程,直到文本串或模式串的末尾
- 失配函数的计算
  - 初始化next[0] = 0,表示空串的最长相等前后缀长度为0。
  - 使用两个指针i和j,其中i表示当前计算的失配函数位置,j表示当前比较的位置。
  - 从左到右遍历模式串,对于每个位置i:
    - 如果模式串的第i个字符与第j个字符相等,则next[i] = j + 1,并将j向右移动一位。
    - 如果模式串的第i个字符与第j个字符不相等,则将j回退到next[j-1]的位置,继续比较。
    - 如果j等于0且模式串的第i个字符与第j个字符不相等,则next[i] = 0,并将j保持为0。

```C++
// 伪代码
function KMP(text, pattern):function computeFailureFunction(pattern):
    m = length(pattern)
    failure[0] = 0
    i = 1
    j = 0
    while i < m:
        if pattern[i] == pattern[j]:
            failure[i] = j + 1
            i = i + 1
            j = j + 1
        else if j > 0:
            j = failure[j - 1]
        else:
            failure[i] = 0
            i = i + 1
    return failure

function KMPSearch(text, pattern):
    n = length(text)
    m = length(pattern)
    failure = computeFailureFunction(pattern)
    i = 0
    j = 0
    while i < n:
        if text[i] == pattern[j]:
            if j == m - 1:
                return i - m + 1
            i = i + 1
            j = j + 1
        else if j > 0:
            j = failure[j - 1]
        else:
            i = i + 1
    return -1
```

### KMP算法的时间复杂度分析

- 计算失配函数的时间复杂度为O(m),其中m是模式串的长度
- 利用失配函数进行匹配的时间复杂度为O(n),其中n是文本串的长度。
- 因此,KMP算法的总时间复杂度为O(m+n)。

### 应用

- 字符串搜索:在文本编辑器、文本处理工具中查找特定的子串。
- 模式匹配:在DNA序列分析、病毒检测等领域中进行模式匹配。
- 数据压缩:在数据压缩算法中,KMP算法可用于查找重复的子串。
- 语法分析:在编译器的词法分析和语法分析中,KMP算法可用于匹配关键字和语法规则
