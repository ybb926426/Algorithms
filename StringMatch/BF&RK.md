## BF算法
BF算法是 Brute Force 的缩写，中文叫做暴力匹配算法，也叫做朴素匹配算法

- 主串 我们在字符串A中查找字符串B，那字符串A就是主串，字符串B就是模式串。我们把主串的长度记做n，模式串长度记做m；因为我们是在主串中查找模式串，所以n>m；
- 模式串

核心思想：我们在主串中，检查其实位置分别是 0、1、2....n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式传匹配的
理论上，BF 算法时间复杂度很高，是 O(n\*m)，举个例子，极端情况下，比如主串是“aaaaaa...aaaa”，模式串是“aaaaab”，我们每次都要比对m个字符串，要比对n-m+1次，所以这种算法的最坏情况时间复杂度是O(n\*m)
实际上，确是一个比较常用的字符串匹配算法
- 大多数情况下，模式串和主串长度不会太长，而且每次模式串与主串中的子串匹配是，中途遇到不能匹配的字符时候，就停止，不需要把m个字符串逗比对一下，尽管理论上的最坏时间复杂度是O(n\*m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多
- 朴素字符串匹配算法思想简单，代码实现也简单，在满足性能前提下，简单是首选

## RK算法
RK 算法全称是 Rabin-Karp，是由它的两位发明者 Rabin 和 Karp 的名字来命名的，这个算法理解起来也不是很难，其实就是 BF 算法的升级版；

我们对 朴素字符串匹配算法 稍加改造，引入哈希算法，时间复杂度就回降低

核心思路：我们通过哈希算法对主串中的 n-m+1 个子串分别秋哈希值，然后逐个与模式串的哈希值比较大小；如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了；因为哈希值是一个数字，数字之间的比较是非常快速的，所以模式串和子串的效率就提高了；
不过，通过哈希算法计算子串哈希值的时候，我们需要遍历子串的每个字符，尽管模式串与子串比较的效率提高了，但是整体算法的效率并没有提高，这个时候就需要哈希算法设计的非常有技巧了；我们假设要匹配的字符串的字符集中只包含 K 个字符，我们可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。