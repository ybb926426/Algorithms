# 堆

堆(Heap)是一种特殊的树形数据结构,它满足以下性质

- 堆是一个完全二叉树：意味着除了底层外，所有层都完全填满，并且最低层的节点尽可能地从左到右填充
- 堆中的每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值
  - 对于每个节点的值都大于等于子树中每个节点值的堆，叫大顶堆；
  - 对于每个节点的值都小于等于子树中每个节点值的堆，叫小顶堆；

## 堆的实现

堆通常用数组来实现，因为完全二叉树可以很容易地用数组表示。在数组表示中,如果一个节点的索引为i,那么它的左子节点的索引为2i+1,右子节点的索引为2i+2,父节点的索引为(i-1)/2

## 支持的主要操作

- 插入：将一个新元素插入到堆中
- 删除最大/最小 从堆中删除并返回最大或最小的元素
- 查看最大/最小 返回最大或最小的元素,但不删除它

## 应用

- 优先队列实现
- 在堆排序算法中用于排序
- 在图算法中，如Dijkstra的最短路径算法和Prim的最小生成树算法
- 在某些问题中,如找到第K个最大或最小的元素

## 堆排序石英钟原地的，时间复杂度为 O(nlogn) 的排序算法

## 如何实现一个堆

- 首先要知道堆支持哪些操作以及如何存储一个堆
- 完全二叉树比较适合用数组来存储，用数组来存储完全二叉树是非常节省内存空间的，因为我们不需要存储左右子节点的指针，单纯的通过数组的下标，就可以找到一个节点的左右子节点和父节点

- 往堆中插入一个元素，需要进行堆化
  - 堆化有两种方式
    - 从下往上
    - 从上往下

## 堆排序

堆排序的时间复杂度非常稳定，是 O(nlogn)，并且是原地排序算法
我们可以把堆排序过程大致分解为两个阶段

- 建堆
- 排序

## 堆的应用

- 优先级队列
  - 顾名思义，首先是个队列；队列最大特性就是先进先出，不过，在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队；
  - 往优先级队列中插入一个元素，就相当于王堆中插入一个元素；从优先级对列中取出优先级最高的元素，相当于取出堆顶元素；
- 利用堆求 Top K
  - 一类是针对静态数据集合，也就是说数据集合事先确定，不会再变
    - 我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与对顶元素比较，如果比堆顶元素大，我们就把堆顶元素删除，并将这个元素插入堆中；如果比堆顶元素小，则不作处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了
  - 另一类是针对动态数据集合，也就是说数据集合事先不确定，有数据动态的加入到集合中
    - 我们可以一致维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与对顶元素比对。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不作处理；等到数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了；
- 利用堆求中位数
  - 中位数，顾名思义，就是处在中间位置的那个数。如果数据的个数是奇数，把数据从小到大排序，那第 n/2+1 个数据就是中位数；如果个数是偶数的话，那处于中间位置的数据有两个，第 n/2 个和第 n/2 + 1 个数据，这个时候，我们可以随意取一个作为中位数
    - 对于一组静态数据，中位数是固定的，我们可以先排序，第 n/2 个数据就是中位数；尽管排序代价比较大，但是边际成本会很小；
    - 但是如果我们面对的是动态数据集合，中位数在不停的变动，如果再用先排序的方法，每次询问中位数的时候，都要先进行排序，那效率就不高了
      - 借助堆这种数据结构，我们不用排序，就可以非常高效的实现求中位数的操作
      - 我们需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆存储前半部分数据，小顶堆存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据；
      - 也就是说，如果有 n 个数据，n 是偶数，我们从小到大排序，那前 n/2 个数据存储在大顶堆中， 后 n/2 个数据存储在小顶堆中，这样，大顶堆中的堆顶元素就是我们要找的中位数。如果 n 是奇数，情况是类似的，大顶堆就存储 n/2 + 1 个数据，小顶堆中就存储 n/2 个数据；
      - 数据是动态变化的，如果新加入的数据小于等于大顶堆的堆顶元素，我们就把这个数据插入大顶堆中；否则，插入小顶堆；
      - 这个时候，就出现了两个堆中数据个数不符合前面约定的情况，如果 n 是偶数，两个堆中的数据都是 n/2;如果 n 是奇数，大顶堆有 n/2 + 1 个数据，小顶堆有 n/2 个数据。这个时候，我们可以从一个堆中不停的将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。
      - 利用两个堆不仅可以求出中位数，还可以快速求出其他百分位的数据，原理是类似的；
      - 假设求 99% 响应时间，大顶堆存 n*99% 个数据，小顶堆中存 n*1%个数据，大顶堆堆顶的数据就是我们要找的 99% 响应时间
      - 每次插入一个数据的时候，我们要判断这个数据跟大顶堆和小顶堆堆顶数据的大小关系，然后决定插入到哪个堆中。如果这个新插入的数据比大顶堆的堆顶数据小，那就插入大顶堆；如果这个新插入的数据比小顶堆的堆顶数据大，那就插入小顶堆。
      - 但是，为了保持大顶堆中的数据占 99%，小顶堆中的数据占 1%，在每次新插入数据之后，我们都要重新计算，这个时候大顶堆和小顶堆中的数据个数，是否还符合 99:1 这个比例。如果不符合，我们就将一个堆中的数据移动到另一个堆，直到满足这个比例
