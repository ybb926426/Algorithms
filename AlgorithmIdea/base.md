# 算法思想

## 分治(Divide and Conquer)

将一个复杂的问题分解成若干个相同或相似的子问题，递归地解决这些子问题，然后将子问题的解合并得到原来的解

典型问题：归并排序、快速排序、二分搜索等

## 回溯(Backtracking)

回溯是一种通过探索所有可能的候选解来找出所有解的算法。在搜索过程中，如果当前的候选解不能满足问题的约束条件，就回溯到上一步，尝试其他的候选解

典型问题：N皇后问题、子集和问题、图的着色问题

## 枚举(Enum)

枚举是一种暴力搜索算法思想，通过列举所有可能的情况来找到问题的解

对于小规模的问题，枚举可以快速得到解，但对于大规模问题，枚举的效率比较低

典型问题：生成排列、组合等

## 贪心(Greddy)

贪心算法在每一步选择中都采取当前状态下最优的选择，以期望得到全局的最优解

贪心算法通常用于优化问题：如求解最大值或最小值

典型问题：霍夫曼编码、最小生成树、背包问题

## 动态规划(Dynamic Programming)

动态规划通过将问题分解成相互重叠的子问题，并存储子问题的解来避免重复计算。

动态规划通常用于优化递归问题，通过填表的方式自底向上地计算最优解

典型问题：斐波那契数列、最长公共子序列、背包问题

## 分支限界法(Branch and Bound)

分支限界是一种在解空间树上搜索最优解地算法

通过计算当前节点的下界，剪枝掉不可能得到最优解的分支，从而缩小搜索空间

典型问题：旅行商问题、0-1背包问题

## 随机化(Randomization)

随机化算法通过引入随机性来解决问题，通常用于处理最坏情况下性能较差的问题。

随机化算法可以在平均情况下获得较好的性能

典型问题：快速排序的随机化版本、跳跃表等
